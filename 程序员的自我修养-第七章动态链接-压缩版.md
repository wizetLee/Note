第七章：动态链接

- 7.1 为什么要动态链接

    静态链接缺点：浪费内存和磁盘空间、模块更新困难

    - 内存和磁盘空间

        - 试想一下如果每个程序内部都保留着相同的公用库的函数，如果这些库都是静态链接的，那么每个程序内存中都需要加载一遍这些公共库，公共库在磁盘和内存中都有多份副本，那么这部分的空间就被浪费了。

    - 程序开放和发布
        - 静态链接对程序的更新、部署和发布带了很多麻烦，如一旦程序中任何模块更新。整个程序就要重新链接、发布给用户，导致整个程序都要重新下载。

    - 动态链接
        - 解决空间浪费和更新坤能的最简单的方法就是把程序的模块相互分割开来，形成独立的文件，而不再将他们静态地链接在一起。简单而言，就是不对那些组成程序地目标文件进行连接，等到程序要运行时才进行连接，也就是把连接这个过程延迟到运行时再进行，这就是动态链接（Dynamic Linking）的基本思想。

        - 当我们要升级程序库或程序共享的某个模块时，理论上只要简单地将旧版本的目标文件覆盖掉，尔福煦江苏哦有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件就会本自动装载到内存并且链接起来，程序就完成了升级的目标。

    - 程序可扩展性和兼容性
        - 动态链接还可以再运行时动态地选择加载各种程序模块，这个优点就是后来被人们用来制作程序地`插件（Plug-in）`。动态库还相当于在程序和操作系统之间增加了一个中间层，从而消除了程序对不同平台之间依赖地差异性。但需要注意地是，如果动态库地新版本与旧版本之间地接口不兼容，就会导致原有地程序无法运行。

    - 动态链接的基本实现

        - 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将他们链接在一起形成一个完成的程序，而不是像静态链接一样把所有的程序模块都链接成一个单独的可执行文件。

        - 动态链接期间涉及多个文件为加载，需要有操作系统的支持。动态链接情况下，进程的虚拟地址空间的分布比静态链接情况复杂。Linux系统中，ELF动态链接文件被称为动态共享对象（Dynamic Shared Objects），简称共享对象，一般以.so为扩展名。

        - 程序与动态库的链接工具由动态链接器完成，由于动态库的链接过程被推迟到装载的时候，因此会导致程序在性能上的损失。可以使用延迟绑定（Lazy Binding）等方法使得这种性能损失尽可能地减少。


- 7.2 简单的动态链接的例子

    - 链接器在解析符号时，如果符号是定义在其他静态目标文件的函数，连机器就会按照静态链接的规则将符号地址重定位。如果是定义在一个动态共享库的函数，那么链接器就是将这个符号的引用标记为一个动态链接的符号，不对它进行地址重定位，把这个过程留到装载时再进行。

    - 一个问题是怎么知道符号是静态符号还是动态符号。动态库中保存了完整的符号信息（因为运行时进行动态链接还需要使用符号信息），链接器在解析符号时就知道，符号是定义在动态库中，这样链接器就可以对该符号的引用做特殊的处理，使它成为一个对动态符号的引用。


    - 动态链接程序运行时地址空间分布

        - 在系统开始运行程序前，首先会把控制权交给动态链接器，由它完成所有的动态链接工作以后再把控制权交给程序，再执行。

        - 共享对象的最终装载地址再编译时是不确定的，装载器根据当前地址空间的空闲情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象。



- 7.3 地址无关代码

    - 7.3.1 固定装载地址的困扰

        共享对象在装载时，如何确定它在进程虚拟地址空间的位置？早期使用的静态共享库，使用的是链接时重定位，这会引发许多问题，如地址冲突等.(详情看书)

    - 7.3.2 装载时重定位

        在链接时，对所有绝对地址的引用不作重定位，而是把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。这种叫做`装载重定位（Load Time Relocation）`，在Windows中叫`基址重定位（Rebasing）`。

        另一个问题是动态连接模块被装载映射到虚拟空间后，指令部分在多个进程共享的，由于装载时重定位的这种方式需要修改指令，所以没有办法做到同一份指令可被多个进程共享，因为指令被重定位后对于每个进程来讲都是不同的。当然，动态链接库中的`可修改数据部分对于不同的进程来说有多个副本`，所以它们可以采用装载时重定位的方法来解决。

    - 7.3.3 地址无关代码

        - 装载时重定位是解决动态模块中有绝对地址引用的办法之一，`但如上面说的就是指令部分无法在多个进程之间共享`，这样就失去了动态链接库节省内存的一大优势。

        - 我们的目的是希望程序模块中共享的指令部分在装载时，不需要因为装载地址的改变而改变，所以实现的`基本想法就是将指令中那些需要被修改的部分分离出来，与数据部分放在一起(GOT)`，这样质量部分就可以保持部分，而数据部分可以在每个进程中拥有一个副本。这种方案目前被称为地址无关代码（Position-independent Code）技术。

        - 模块间数据访问：(外部引用)

            - `模块间的数据访问目标地址要等到装载时才决定，ELF的做法是在数据段中建立一个只想这些变量的指针数组，也被称为全局偏移表（Global Offset Table），当代码需要引用该全局变量时，可以通过GOT中相应的项间接引用。当指令中需要访问某些动态符号时，程序先找到GOT，然后根据GOT中变量对应的项找到变量的目标地址，每个变量对应一个地址，链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT中各个项，确保每个指针指向的地址正确。由于GOT是放在数据段的，所以他在模块装载时被修改，并且每个进程都可以有独立的副本，相互不受到影响。`


- 7.4 延迟绑定（PLT）

    


- 7.5 动态链接相关结构


- 7.6 动态链接的步骤和实现


- 7.7 显式运行时链接


- 7.8 总结